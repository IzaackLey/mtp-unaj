<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js ie6" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8" lang="en"> <![endif]-->
<!--[if gt IE 8]><!-->  <html class="no-js" lang="en"> <!--<![endif]-->
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	
	<title>Observer</title>
	
	<meta name="description" content="A jQuery library for modern HTML presentations">
	<meta name="author" content="Caleb Troughton">
	<meta name="viewport" content="width=1024, user-scalable=no">
	
	<!-- Core and extension CSS files -->
	<link rel="stylesheet" href="../core/deck.core.css">
	<link rel="stylesheet" href="../extensions/goto/deck.goto.css">
	<link rel="stylesheet" href="../extensions/menu/deck.menu.css">
	<link rel="stylesheet" href="../extensions/navigation/deck.navigation.css">
	<link rel="stylesheet" href="../extensions/status/deck.status.css">
	<link rel="stylesheet" href="../extensions/hash/deck.hash.css">
	<link rel="stylesheet" href="../extensions/scale/deck.scale.css">
	
	<!-- Style theme. More available in /themes/style/ or create your own. -->
	<link rel="stylesheet" href="../themes/style/swiss.css">
	
	<!-- Transition theme. More available in /themes/transition/ or create your own. -->
	<link rel="stylesheet" href="../themes/transition/horizontal-slide.css">
	
	<script src="../modernizr.custom.js"></script>
	

    <!-- SintaxHighlighter -->
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>SyntaxHighlighter Large File Demo</title>
	<script type="text/javascript" src="../SyntaxHighlighter-master/scripts/XRegExp.js"></script>
	<script type="text/javascript" src="../SyntaxHighlighter-master/scripts/shCore.js"></script>
	<script type="text/javascript" src="../SyntaxHighlighter-master/scripts/shBrushJava.js"></script>
	<script type="text/javascript" src="../SyntaxHighlighter-master/scripts/shBrushPlain.js"></script>
	<script type="text/javascript" src="../SyntaxHighlighter-master/scripts/shBrushPython.js"></script>
	<link type="text/css" rel="stylesheet" href="../SyntaxHighlighter-master/styles/shCoreEclipse.css"/>
	<!--link type="text/css" rel="stylesheet" href="../SyntaxHighlighter-master/styles/shThemeEclipse.css"/-->
	
	<script type="text/javascript">SyntaxHighlighter.all();</script>

	
	
</head>

<body class="deck-container">

<!-- Begin slides -->
<section class="slide" id="observer1">
	<h2>Estación Meterológica</h2>
	<p>Tenemos que hacer una api una estación metereológica para que pueda ser extendida y que se puedan agregar otros elementos de visualización </p>
	<p><strong>API:</strong>(Application Programming Interface o Interfaz de programación de aplicaciones) es el conjunto de funciones y procedimientos (o métodos, en la programación orientada a objetos) que ofrece cierta biblioteca para ser utilizado por otro software como una capa de abstracción.</p>
	<h3>Esquema de funcionamiento</h3>
	<img src="whetherStationDraw.png">
	<p>Tres son las partes que intervienen en la estación metereológica</p>
	<ul>
		<li>El dispositivo fisico: que toma los datos de los sensores</li>
		<li>WhetherData object: toma los datos que viene de la estacion meterológica y actualiza los dispostivos de visualización, este sabe como comunicarse con el dispositivo físico para obtener los datos actualizados y luego actualizar los display que muestran la información</li>
		<li>El diaplay: que muestra los datos del tiempo actuales</li>
	</ul>
	<p>El objetivo del programa es actualizar los displays cuando alla algún cambio en los datos sensados</p>
</section>

<section class="slide" id="strategy2">
	<h2>Estación Meterológica</h2>
	<p>El clase WhetherData viene con 3 metodos implementados que son los que obtienen los datos de la estación metereológica, estos son getTemperature(), getHumidity(), getPressure() y un método measurementsChanged() que es invocado por la central metereológica cada vez que hay un cambio en las mediciones</p>
	<img src="factoryWhetherDataClass.png"/>
	<p>Nuestra tarea es implementar 3 displays que se alimenten de los datos recolectados por la estación metereológica, y el método measurementsChanged() de tal manera que se actualicen los displays con las nuevos datos adequiridos</p>
</section>
<section class="slide" id="strategy3">
	<h2>Estación Meterológica</h2>
	<p>No tenemos idea como es la implementación de los getters, ni como hace las estación meterelógica para saber cuando invocar a el metodo measurementsChanged(), pero sabemos que cuando esto ocurre tenemos que leer los datos de la centra y actualizar la información en los displys</p>
	<p>El sistema tiene que se expandible para que otros desarrolladores puedan crear nuevos displays personalizados y que además los usuarios puedan agregar y sacar displays de la apliación</p>
</section>
<section class="slide" id="strategy4">
	<h2>Primera implementación</h2>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
	public class WeatherData {
		public void measurementChanged(){
			float temp = getTemperature();
			float humidity = getHumidity();
			float pressure = getPressure();

			currentConditionsDisplays.update(temp, humidity, pressure);
			statisticsDisplay.update(temp, humidity, pressure);
			forecastDisplay.update(temp, humidity, pressure);
		}
		//other code here
	}
	</script>
	<p><strong>Qué afirmaciones son ciertas con respecto al código anterior</strong></p>
	<ul>
		<li>Estamos referenciando implementaciones concretas, no interfaces.</li>
		En realidad no sabemos si estan declarados a un supertipo o a un tipo concreto.
		Podría haber estado declarado asi:
		<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
			CurrentConditionsDisplays currentConditionsDisplays;
		</script>
		en cuyo caso sí, se estaría referenciado a una implementación concreta, o así:
		<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
			Display currentConditionsDisplays;
		</script>
		<p>en cuyo caso no estaría referenciado a una interfaz, o estar así.</p>
		<p>El hecho de que el nombre del atributo sea específico y no generico, nos da la idea de que en realidad, si se esta referenciando implementaciones concretas, si se hubieran declarado referenciando a un supertipo se hubiera puesto algo asi:</p>
		<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
			display1.update(temp, humidity, pressure);
			display2.update(temp, humidity, pressure);
			display3.update(temp, humidity, pressure);
		</script>
		</li>
	</ul>
</section>
<section class="slide" id="strategy5">
	<h2>Primera implementación</h2>
	<p><strong>Qué afirmaciones son ciertas con respecto al código anterior</strong></p>
	<ul>
		<li>Para cada display nuevo tenemos que modificar el código.
		Si en la afirmación anterior dijimos que estabamos referenciando a un tipo concreto entonces, esta es si, ya que una ves que declaramos un atributo de un tipo concreto no podemos cambiarlo en tiempo de ejecución.
		<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
			CurrentConditionsDisplays currentConditionsDisplays;
		</script>
		<p>y en otra parte hace esto</p>
		<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
			currentConditionsDisplays = new StatisticsDisplay();
		</script>
		<p>Ya que estamos atados a un tipo concreto determinado</p>
		</li>
		<li>No tenemos forma de agragar elementos en tiempo de ejecución.
		<p>Para podes cambiar la cantidad de elementos en tiempo de ejecución necesitariamos una interfaz que referencia a una interface</p>
		</li>
		<li>Los elementos Display no implementan una interfaz comun.</li>
		<li>No encapsulamos la parte que cambia.
		Por ahora para agregar un display los programadores tiene que tocar el código de la clase WhetherDataObjet	
		</li>
		<li>Estamos violando el encapsulamiento de la clase WeatherData.</li>
	</ul>
</section>
<section class="slide" id="strategy6">
	<h2>Patrón Obsrver</h2>
	<h3>Suscripción una a revista</h3>
	<ul>
		<li>Hay distintas revistas que hacen sus publicaciones.</li>
		<li>Nos podemos subscribir a las revistas que nos interesa recibir publicaciones.</li>
		<li>El editor de la revista envía cada publicación nueva a todos los que estén suscritos.</li>
		<li>Nos podemos des subscribir cuando no queramos seguir recibiendo las revistas</li>
	</ul>
	<p>Si entendemos esto entonces entendemos como trabaja el patrón observer, con la pequeña diferencia que en el patrón llamamos <strong>Subject</strong> al editor y <strong>observers</strong> los subcriptores</p>
</section>
<section class="slide" id="strategy7">
	<h2>Patrón Obsrver</h2>
	<p>Define una dependencia de uno-a-muchos entre objetos de forma que, cuando un objeto cambia de estado, se notifica a los objetos dependientes para que se actualicen automáticamente.<p/>
	<ul>
		<li>Clasificación:</li>
		<li>Motivación: </li>
		<ul>
			<li>Mantener la consistencia entre objetos relacionados, sin aumentar el acoplamiento entre clases.</li>
			<li>En un toolkit de GUI, separar los objetos de presentación (vistas) de los objetos de datos, de forma que se puedan tener varias vistas sincronizadas de los mismos datos (editor-subscriptor)</li>
		</ul>	
		<li>Aplicabilidad:</li>
		<ul>
			<li>Cuando una abstracción tiene dos aspectos, y uno depende del otro. Encapsular los aspectos en objetos distintos permite cambiarlos y reutilizarlos.</li>
			<li>Cuando cambiar un objeto implica cambiar otros, pero no sabemos exactamente cuántos hay que cambiar</li>
			<li>Cuando un objeto debe ser capaz de notificar algo a otros sin hacer suposiciones sobre quiénes son dichos objetos. Esto es, cuando se quiere bajo acoplamiento.</li>
		</ul>
	</ul>
	<p>Si entendemos esto entonces entendemos como trabaja el patrón observer, con la pequeña diferencia que en el patrón llamamos <strong>Subject</strong> al editor y <strong>observers</strong> los subcriptores</p>
</section>
<section class="slide" id="strategy8">
	<h2>Patrón Obsrver</h2>
	<ul>
		<li>Consecuencias: </li>
		<ul>
			<li>Permite modificar sujetos y observadores de manera independiente</li>
			<li>Permite reutilizar un sujeto sin reutilizar sus observadores, y viceversa</li>
			<li>Permite añadir observadores sin tener que cambiar el sujeto ni los demás observadores</li>
			<li>El sujeto no sabe la clase concreta de sus observadores (mínimo acoplamiento)</li>
			<li>El sujeto envía la notificación a todos los observadores suscritos (broadcast). Se pueden añadir/quitar observadores.</li>
			<li>Una operación en el sujeto puede desencadenar cambios de estado en sus observadores.</li>
		</ul>	
		<li>Participantes:</li>
		<ul>
			<li>Subject:conoce a sus observadores, que pueden ser un número arbitrario y proporciona una interfaz para añadir y quitar objetos observadores</li>
			<li>Observer: define la interfaz de los objetos a los que se deben notificar cambios en un sujeto</li>
			<li>ConcreteSubject: almacena el estado de interés para sus observadores y envía notificaciones a sus observadores cuando su estado cambia</li>
			<li>ConcreteObserver: mantiene una referencia a un ConcreteSubject, almacena el estado del sujeto que le resulta de interés, implementa la interfaz de Observer para mantener su estado consistente con el del sujeto</li>
		</ul>
	</ul>
</section>
<section class="slide" id="strategy9">
	<h2>Patrón Obsrver</h2>
	<ul>
		<li>Estructura:
		<img src="observerClassDiagram.png"/></li>
	</ul>	
</section>
<section class="slide" id="strategy10">
	<h2>Patrón Obsrver</h2>
	<ul>
		<li>Por que decimos que la relación es de uno a muchos?<br>
			Con el patrón observer el Sujeto es el contiene el estado y lo controla. Osea hay un solo objeto con estado</li>
		<li>Los observadores por el otro lado usan el estado por mas que no lo contengan. Todos los observadores que estan observando un objeto delegan la responsbilidad de ser avisados cuando hay un cambio de estado</li>
		<li>La relación es un sujeto, muchos obsrvadores</li>
	</ul>
</section>
<section class="slide" id="strategy11">
	<h2>Implementación</h2>
	<img src="whetherStationObserver.png"/> 

</section>	

<section class="slide" id="strategy20">
	<h2>Principio de diseño</h2>
	<ul>
		<li>El poder del bajo acoplamiento: cuando dos objetos estan debilmente acoplados pueden interactuar, pero tienen poco conocimiento el uno del otro.<li/>
		<li>El patrón Obsrever provee un dieseño donde los sujetos y observadores estan debilmente acoplados</li>
		<li></li>
	</ul>	
</section>
<!----------------------------------------------------------------------------------------------->
<!-- deck.navigation snippet -->
<a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
<a href="#" class="deck-next-link" title="Next">&#8594;</a>

<!-- deck.status snippet -->
<p class="deck-status">
	<span class="deck-status-current"></span>
	/
	<span class="deck-status-total"></span>
</p>

<!-- deck.goto snippet -->
<form action="." method="get" class="goto-form">
	<label for="goto-slide">Go to slide:</label>
	<input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
	<datalist id="goto-datalist"></datalist>
	<input type="submit" value="Go">
</form>

<!-- deck.hash snippet -->
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>


<!-- Grab CDN jQuery, with a protocol relative URL; fall back to local if offline -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="../jquery-1.7.2.min.js"><\/script>')</script>

<!-- Deck Core and extensions -->
<script src="../core/deck.core.js"></script>
<script src="../extensions/hash/deck.hash.js"></script>
<script src="../extensions/menu/deck.menu.js"></script>
<script src="../extensions/goto/deck.goto.js"></script>
<script src="../extensions/status/deck.status.js"></script>
<script src="../extensions/navigation/deck.navigation.js"></script>
<script src="../extensions/scale/deck.scale.js"></script>

<!-- Initialize the deck -->
<script>
$(function() {
	$.deck('.slide');
});
</script>

</body>



</html>
