<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js ie6" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8" lang="en"> <![endif]-->
<!--[if gt IE 8]><!-->  <html class="no-js" lang="en"> <!--<![endif]-->
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	
	<title>Adapter</title>
	
	<meta name="description" content="A jQuery library for modern HTML presentations">
	<meta name="author" content="Caleb Troughton">
	<meta name="viewport" content="width=1024, user-scalable=no">
	
	<!-- Core and extension CSS files -->
	<link rel="stylesheet" href="../core/deck.core.css">
	<link rel="stylesheet" href="../extensions/goto/deck.goto.css">
	<link rel="stylesheet" href="../extensions/menu/deck.menu.css">
	<link rel="stylesheet" href="../extensions/navigation/deck.navigation.css">
	<link rel="stylesheet" href="../extensions/status/deck.status.css">
	<link rel="stylesheet" href="../extensions/hash/deck.hash.css">
	<link rel="stylesheet" href="../extensions/scale/deck.scale.css">
	
	<!-- Style theme. More available in /themes/style/ or create your own. -->
	<link rel="stylesheet" href="../themes/style/swiss.css">
	
	<!-- Transition theme. More available in /themes/transition/ or create your own. -->
	<link rel="stylesheet" href="../themes/transition/horizontal-slide.css">
	
	<script src="../modernizr.custom.js"></script>
	

    <!-- SintaxHighlighter -->
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>SyntaxHighlighter Large File Demo</title>
	<script type="text/javascript" src="../SyntaxHighlighter-master/scripts/XRegExp.js"></script>
	<script type="text/javascript" src="../SyntaxHighlighter-master/scripts/shCore.js"></script>
	<script type="text/javascript" src="../SyntaxHighlighter-master/scripts/shBrushJava.js"></script>
	<script type="text/javascript" src="../SyntaxHighlighter-master/scripts/shBrushPlain.js"></script>
	<script type="text/javascript" src="../SyntaxHighlighter-master/scripts/shBrushPython.js"></script>
	<link type="text/css" rel="stylesheet" href="../SyntaxHighlighter-master/styles/shCoreEclipse.css"/>
	<!--link type="text/css" rel="stylesheet" href="../SyntaxHighlighter-master/styles/shThemeEclipse.css"/-->
	
	<script type="text/javascript">SyntaxHighlighter.all();</script>

	
	
</head>

<body class="deck-container">

<!-- Begin slides -->
<section class="slide" id="strategy1">
	<h2>Adapter</h2>
	<h3>Adaptadores de Objetos</h3>
	<p>Supongamos que tenemos un software que necesitamos hacer andar una nueva libreria que tiene un diseño distinto en la interfaces que el software base.</p>
	<img src="adapter1.png"/>
	<p>No queremos tocar el codigo del software de base y no podemos cambiar el codigo de las librerias. Lo que podemos hacer es escribir una clase que adapte la interfaz de la libreria a la del software que tenemos.</p>
	<img src="adapter2.png"/>

</section>

<section class="slide" id="adapter2">
	<h2>Adapter</h2>
	<p>Acemos una version distinta de la implementacion de los patos para ver el adapter y agregamos pavos que implementan una interfaz distinta.</p>
	<p>La interfaz de los patos</p>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
		public interface Duck {
			public void quack();
			public void fly();
		}
	</script>
	<p>Vemos como queda un pato cuando implemneta la interfaz Duck</p>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
		public class MallardDuck implements Duck {
			public void quack() {
				System.out.println("Quack");
			}
		 
			public void fly() {
				System.out.println("I'm flying");
			}
		}
	</script>
</section>

<section class="slide" id="adapter3">
	<h2>Adapter</h2>
	<p>Ahora la interfaz de los pavos</p>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
		public interface Turkey {
			public void gobble();
			public void fly();
		}
	</script>
	<p>Vemos como queda un pavo cuando implemneta la interfaz Duck</p>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
		public class WildTurkey implements Turkey {
			public void gobble() {
				System.out.println("Gobble gobble");
			}
		 
			public void fly() {
				System.out.println("I'm flying a short distance");
			}
		}
	</script>
</section>

<section class="slide" id="adapter4">
	<h2>Adapter</h2>
	<p>Si queresmos usar <strong>pavos</strong> en donde esperamos <strong>patos</strong>, como guardar en un variable Duck un Turkey, o pasar un Turkey por parámetro como si fuera un Duck, necesitamos el adaptador que haga que el Turkey parezca un Duck.</p>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
		public class TurkeyAdapter implements Duck {
			Turkey turkey;
			public TurkeyAdapter(Turkey turkey) {
				this.turkey = turkey;
			}
			public void quack() {
				turkey.gobble();
			}
			public void fly() {
				for(int i=0; i < 5; i++) {
					turkey.fly();
				}
			}
		}
	</script>
	<ol>
		<li>Implementamos la interfaz del tipo que esperamos.<BR/>
			Por ejemplo esperamos un parametro tipo Duck, pero queremos que contenga un objeto tipo Turkey.<BR/>
			O en el caso de un método espera un tipo de parametro Duck y queremos pasarle uno tipo Turkey</p>
		<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
			static void testDuck(Duck duck) {
				duck.quack();
				duck.fly();
			}
		</script>
		</li>
	</ol>	
</section>
<section class="slide" id="adapter4b">
	<h2>Adapter</h2>
	<ol start=2>
		<li>En el contructor le pasamos el tipo incompatible al que queremos adaptarlo, lo disfrasamos para que parezca de otra interface. En este caso Turkey
		<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
			public TurkeyAdapter(Turkey turkey) {
				this.turkey = turkey;
			}
		</script>
		</li>
		<li>Como implementamos Duck tenemos que implemnetar quack() y fly() y aca es donde hacemos la traduccion. Cuando llamemos a quack() en realidad el pavo a a ejecutar gobble()
		<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
			public void quack() {
				turkey.gobble();
			}
			public void fly() {
				for(int i=0; i < 5; i++) {
					turkey.fly();
				}
			}
		</script>
		</li>
	</ol>	
</section>
<section class="slide" id="adapter5">
	<h2>Adapter</h2>
	<h3>Testeamos el adapter</h3>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
		public class DuckTestDrive {
			public static void main(String[] args) {
				MallardDuck duck = new MallardDuck();
		 		//creamos un pato

				WildTurkey turkey = new WildTurkey();
				//creamos un pavo

				Duck turkeyAdapter = new TurkeyAdapter(turkey);
		   		//envolvemos al pavo con el adapter y nos queda un pato

				System.out.println("The Turkey says...");
				turkey.gobble();
				turkey.fly();
		 
				System.out.println("\nThe Duck says...");
				testDuck(duck);
		  
				System.out.println("\nThe TurkeyAdapter says...");
				testDuck(turkeyAdapter);
				//llamamos al metodo pasandole un pavo adaptado
			}
		 
			static void testDuck(Duck duck) {
				duck.quack();
				duck.fly();
			}
		}
	</script>
</section>

<section class="slide" id="adapter6">
	<h2>Adapter</h2>
	<h3>Paso a paso lo que hicimos</h3>
	<ol>
		<li>El cliente hace la llamada al adaptador llamando a algun método de la interfaz destino.<BR/>
		En este caso la interfaz destino es Duck.
		<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
			new TurkeyAdapter(new WildTurkey()).quack();
		</script>
		</li>
		<li>El adaptador traduce las llamadas en uno o muchas llamadas al objeto envuelto o contenido por el adapter. En este caso Turkey
		<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
			public void quack() {
				turkey.gobble();
			}
		</script>
		</li>
		<li>El cliente recibie los resultados sin saber que hubo un adapter en el medio haciendo la traduccion.</li>
	</ol>	
</section>
<section class="slide" id="adapter6a">
	<h2>Adapter</h2>
	<h3>Principios de OO en el adapter</h3>
	<ol>
		<li>Usamos la composición para envolver adaptee con una interfaz alterada. Esto tiene la ventaja que podemos usar un adapter con cualquier sublcase del adapter.</li>
		<li>También vemos como el patron enlaza al cliente a una interface no a una implementación, esto significa que podemos usar varios adapters, cada uno adaptando un grupo diferente de clases, o le podemos agregar nuevas implementaciones mientras se implemente la interfaz target.</li>
	</ol>	
</section>

<section class="slide" id="adapter9">
	<h2>Patron Adapter</h2>
	<p>Convierte la interfaz de una clase en otra interfaz que el cliente espera. Adapter deja comunicarse a clases que de otra forma no podrían hacerlo por incompatibilidades de interface.</p>
	<ul>
		<li>Motivación: Cuando tenemos una clase, parametro o varible de instancia que espera una interfaz, y tenemos una que ofrese la misma funcionalidad pero con una interface diferente, y queremos que se puedan comunicar si tener que hacer cambios en el codigo de las clases intervinientes</li>
		<li>Aplicabilidad: 
		<ul>
			<li>Queremos utilizar una clase ya existente, pero cuya interfaz no coincide con la que necesitas</li>
			<li>Queremos crear una clase reutilizable que coopere con otras no relacionadas, es decir, con clases que puedan no tener una interfaz compatible</li>
			<li>Necesites usar varias subclases existentes pero no sea práctico adaptar sus interfaces. Un object adapter puede adaptar la interfaz de la clase padre.</li>
		</ul>	
		</li>
	</ul>	
</section>
<section class="slide" id="adapter10">
	<h2>Patron Adapter</h2>
	<ul>
		<li>Participantes: 
		<ul>
			<li><strong>Target:</strong> define la interfaz específica de dominio que el cliente usa</li>
			<li><strong>Client:</strong> colabora con los objetos que implementan la interfaz definida por el target</li>
			<li><strong>Adaptee:</strong> define una interfaz existente que necesita adaptarse</li>
			<li><strong>Adapter:</strong> adapta la interfaz del objeto adaptado a la definida por el target</li>
		</ul>	
		</li>
		<li>Consecuencias:
		<ul>
			<li>Object adapter: 
			<ul>
				<li>Un adapter funciona con varios adaptees (el mismo adaptee y todas sus subclases)</li>
				<li>Dificulta sobrescribir el comportamiento del adaptee</li>
			</ul>	
			</li>
			<li>Class adapter: 
			<ul>
				<li>El adapter hereda el comportamiento del adaptee, y puede sobrescribirlo</li>
				<li>No sirve para adaptar una clase y todas sus subclases</li>
				<li>Introduce un único objeto, no hace falta un nivel de indirección para obtener el adaptee</li>
			</ul>
			</li>
		</ul>	
		</li>	
	</ul>	
</section>
<section class="slide" id="adapter10">
	<h2>Patron Adapter</h2>
	<ul>
		<li>			
			<p>Obeject Adapter</p>
			<img src="objectAdapterClassDiagram.png"/>
		</li>
		<li>
			<p>Class Adapter</p>
			<img src="classAdapterClassDiagram.png"/>
		</li>
	</ul>	
</section>

<section class="slide" id="adapter11">
	<h2>Adapter</h2>
	<h3>Object Adapter y Class Adapter</h3>
	<p>Hay dos implementaciones del patrón Adapter, Object Adapter y Class Adapter</p>
	<ul>
		<li>
			<p>Object Adapter</p>
			<p>Pros:</p>
			<ul>
				<li>Más flexible que class Adapter</li>
				<li>No requiere usar herencia</li>
				<li>Adapter funciona con Adaptee y todas sus subclases</li>
			</ul>
			<p>Contras:</p>
			<ul>
				<li>Más difícil sobreescribir el comportamiento de Adaptee</li>
				<li>Requiere más código en la implementación</li>
			</ul>
		</li>
		<li>
			<p>Class Adapter</p>
			<p>Pros:</p>
			<ul>
				<li>menos codigo que object adapter</li>
				<li>puede sobreescribir el comportamiento de Adaptee si se requiere</li>
			</ul>
			<p>Contras:</p>
			<ul>
				<li>Requiere hacer uso de herencia (herencia simple)</li>
				<li>Menos felxible que object Adapter</li>
			</ul>
		</li>
			
	</ul>	
</section>


<section class="slide" id="strategy27">
	<h2>Referencias</h2>
	<p>Head First Design Patterns</p>
</section>
<!----------------------------------------------------------------------------------------------->
<!-- deck.navigation snippet -->
<a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
<a href="#" class="deck-next-link" title="Next">&#8594;</a>

<!-- deck.status snippet -->
<p class="deck-status">
	<span class="deck-status-current"></span>
	/
	<span class="deck-status-total"></span>
</p>

<!-- deck.goto snippet -->
<form action="." method="get" class="goto-form">
	<label for="goto-slide">Go to slide:</label>
	<input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
	<datalist id="goto-datalist"></datalist>
	<input type="submit" value="Go">
</form>

<!-- deck.hash snippet -->
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>


<!-- Grab CDN jQuery, with a protocol relative URL; fall back to local if offline -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="../jquery-1.7.2.min.js"><\/script>')</script>

<!-- Deck Core and extensions -->
<script src="../core/deck.core.js"></script>
<script src="../extensions/hash/deck.hash.js"></script>
<script src="../extensions/menu/deck.menu.js"></script>
<script src="../extensions/goto/deck.goto.js"></script>
<script src="../extensions/status/deck.status.js"></script>
<script src="../extensions/navigation/deck.navigation.js"></script>
<script src="../extensions/scale/deck.scale.js"></script>

<!-- Initialize the deck -->
<script>
$(function() {
	$.deck('.slide');
});
</script>

</body>



</html>
