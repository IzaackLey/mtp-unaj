<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js ie6" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8" lang="en"> <![endif]-->
<!--[if gt IE 8]><!-->  <html class="no-js" lang="en"> <!--<![endif]-->
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	
	<title>Getting Started with deck.js</title>
	
	<meta name="description" content="A jQuery library for modern HTML presentations">
	<meta name="author" content="Caleb Troughton">
	<meta name="viewport" content="width=1024, user-scalable=no">
	
	<!-- Core and extension CSS files -->
	<link rel="stylesheet" href="../core/deck.core.css">
	<link rel="stylesheet" href="../extensions/goto/deck.goto.css">
	<link rel="stylesheet" href="../extensions/menu/deck.menu.css">
	<link rel="stylesheet" href="../extensions/navigation/deck.navigation.css">
	<link rel="stylesheet" href="../extensions/status/deck.status.css">
	<link rel="stylesheet" href="../extensions/hash/deck.hash.css">
	<link rel="stylesheet" href="../extensions/scale/deck.scale.css">
	
	<!-- Style theme. More available in /themes/style/ or create your own. -->
	<link rel="stylesheet" href="../themes/style/swiss.css">
	
	<!-- Transition theme. More available in /themes/transition/ or create your own. -->
	<link rel="stylesheet" href="../themes/transition/horizontal-slide.css">
	
	<script src="../modernizr.custom.js"></script>
	

    <!-- SintaxHighlighter -->
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>SyntaxHighlighter Large File Demo</title>
	<script type="text/javascript" src="../SyntaxHighlighter-master/scripts/XRegExp.js"></script>
	<script type="text/javascript" src="../SyntaxHighlighter-master/scripts/shCore.js"></script>
	<script type="text/javascript" src="../SyntaxHighlighter-master/scripts/shBrushJava.js"></script>
	<script type="text/javascript" src="../SyntaxHighlighter-master/scripts/shBrushPython.js"></script>
	<link type="text/css" rel="stylesheet" href="../SyntaxHighlighter-master/styles/shCoreEclipse.css"/>
	<!--link type="text/css" rel="stylesheet" href="../SyntaxHighlighter-master/styles/shThemeEclipse.css"/-->
	
	<script type="text/javascript">SyntaxHighlighter.all();</script>

	
	
</head>

<body class="deck-container">

<!-- Begin slides -->
<section class="slide" id="title-slide">
	
	<h1>Repaso de Objetos</h1>
	
</section>

<section class="slide" id="objects-clase">
	<h2>Conceptos fundamentales</h2>
	<ul>
		<li>
			<h3>Clase</h3>
			<p>Definiciones de las propiedades y comportamiento de un tipo de objeto concreto.<BR>
			La instanciación es la lectura de estas definiciones y la creación de un objeto a partir de ellas.</p>
		</li>
		<li>
			<h3>Objeto</h3>
			<p>Entidad provista de un conjunto de propiedades o atributos (datos) y de comportamiento o funcionalidad (métodos), los mismos que consecuentemente reaccionan a eventos. <BR>
			Se corresponden con los objetos reales del mundo que nos rodea, o con objetos internos del sistema (del programa).<BR> Es una instancia a una clase.</p>
		</li>
		<li>
			<h3>Propiedad o atributo</h3>
			<p>Contenedor de un tipo de datos asociados a un objeto (o a una clase de objetos), que hace los datos visibles desde fuera del objeto y esto se define como sus características predeterminadas, y cuyo valor puede ser alterado por la ejecución de algún método.</p>
		</li>
	</ul>
</section>

<section class="slide" id="objects-metodo">
	<h2>Conceptos fundamentales</h2>
	<ul>
		<li>
			<h3>Método</h3>
			<p>Algoritmo asociado a un objeto (o a una clase de objetos), cuya ejecución se desencadena tras la recepción de un "mensaje". Desde el punto de vista del comportamiento, es lo que el objeto puede hacer. Un método puede producir un cambio en las propiedades del objeto, o la generación de un "evento" con un nuevo mensaje para otro objeto del sistema.</p>
		</li>
		<li>
			<h3>Identidad</h3>
			<p>La identidad es la propiedad que permite a un objeto diferenciarse de otros. Generalmente esta propiedad es tal, que da nombre al objeto.
			En programación la identidad de los objetos sirve para comparar si dos objetos son iguales o no. No es raro encontrar que en muchos lenguajes de programación la identidad de un objeto esté determinada por la dirección de memoria de la computadora en la que se encuentra el objeto, pero este comportamiento puede ser variado redefiniendo la identidad del objeto a otra propiedad.</p>
		</li>
		<li>
			<h3>Mensaje</h3>
			<p>Una comunicación dirigida a un objeto, que le ordena que ejecute uno de sus métodos con ciertos parámetros asociados al evento que lo generó.</p>
		</li>
	</ul>
</section>	

<section class="slide" id="objects-comportamiento">
	<h2>Conceptos fundamentales</h2>
	<ul>
		<li>
			<h3>Comportamiento</h3>
			<p>Una comunicación dirigida a un objeto, que le ordena que ejecute uno de sus métodos con ciertos parámetros asociados al evento que lo generó.</p>
		</li>
		<li>
			<h3>Estado</h3>
			<p>El comportamiento de un objeto está directamente relacionado con su funcionalidad y determina las operaciones que este puede realizar o a las que puede responder ante mensajes enviados por otros objetos. La funcionalidad de un objeto está determinada, primariamente, por su responsabilidad. Una de las ventajas fundamentales de la POO es la reusabilidad del código; un objeto es más fácil de reutilizarse en tanto su responsabilidad sea mejor definida y más concreta.</p>
		</li>
	</ul>
</section>

<section class="slide" id="relaciones-asociacion">
	<h2>Relaciones</h2>
	<p>Es posible crear objetos de diferentes clases y establecer una relación entre ellos. Cuando los objetos son relacionados es posible acceder a los miembros de un objeto desde otro objeto.
	Esto supone una ventaja cuando un objeto debe comenzar el procesamiento de información justo en donde otro objeto habría terminado el procesamiento.
	Adicionalmente nos permite pasar información de un objeto a otro y de ahí a otro objeto de forma encadenada.<BR>
	Formas de realizar la relación entre objetos:</p>
	<h3>Asociacion</h3>
	<ul>
		<li>
			hacer una referencia de una clase dentro de otra.
			Al menos un atributo de la clase B es una referencia a la clase A.
		</li>
		<li>
			No es una relación fuerte, es decir, el tiempo de vida de un objeto no depende del otro, es decir La creación de B no implica la creación de A.
				Es una relación duradera
		</li>
		<li>
			Es una relación duradera
		</li>
	</ul>
</section>

<section class="slide" id="relaciones-asociacion2">
	<h2>Relaciones</h2>
	<h3>Asociacion</h3>
	<ul>
		<li>
			Normalmente la conexión entre los objetos se realiza recibiendo la referencia de uno de ellos en el constructor u otro método.
		</li>
		<li>
			Si la relación tiene cardinalidad superior a uno hay que usar un array o una estructura de datos dinámica.
		</li>
		<li>
			La clase B usa a la clase A.
		</li>
		<li>
			La asociación se podría definir como el momento en que dos objetos se unen para trabajar juntos y así, alcanzar una meta.
		</li>
		<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
			public class Customer {

		    private int id;
		    private String firstName;
		    private String lastName;
		    private CreditCard creditCard;

		    public Customer() {
		    }
		    public void setCreditCard(CreditCard creditCard) {
		        this.creditCard = creditCard;
		    }
		    public void creditCardPay(double amount){
		        if (creditCard != null){
		           creditCard.pay(amount) 
		        }
		        else{
					System.out.println('no credit card available');
		        }
			}
		</script>
	
		<li>
			Customer es independiente de CreditCard, puesto que el cliente puede existir sin necesidad de tener asignada una tarjeta de crédito.
		</li>
		<li>
			la creación de creditCard se hace afuera de la clase, puede seguir existiendo la creditCard, sin que exista el cliente.
		</li>
	</ul>
</section>

<section class="slide" id="relaciones-uso">
	<h2>Relaciones</h2>
	<h3>Dependencia o Instanciación (uso)</h3>

	<ul>
		<li>
			Un objeto usa (conoce) a otro cuando puede enviarle mensajes, por ejemplo, para requerir de éste algún servicio. 
		</li>
		<li>
			La clase B necesita de un objeto de la clase A para llevar a caba una funcionalidad.
		</li>
		<li>
			En un método de b se crea un objeto auxiliar de A o en un método de B aparece A como argumento.
		</li>
		<li>
			La durabilidad es temporal.
		</li>
		<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
			perimetro = new Calculador().calcularPerimetro(triangulo);
		</script>
	</ul>
</section>

<section class="slide" id="relaciones-composicion">
	<h2>Relaciones</h2>
	<h3>Composición</h3>

	<ul>
		<li>
			La composición es una relación más fuerte que en asociación, y consiste en que la composición también controla los ciclos de vida de los objetos relacionados. 
		</li>
		<li>
			La Clase todo controla las clase parte, al crear el objeto se crean las partes y al finalizarlos se destruyen todas las partes.

		</li>
		<li>
			Es una relación muy duradera.
		</li>
		<li>
			No hay una implementación especial para este tipo de relaciones, se tratan como asociaciones ordinarias.
			En java el que se encarga de la destrucción de los objetos es el garbaje collector.	
		</li>
		<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
			public class Humano {
				private Cerebro cerebro;
				private Corazón corazon;
				public Humano(){
					this.cerebro = new Cerebro();
					this.corazon = new Corazon();
				}
			}

		</script>
		<li>
			Relación de composición entre humano y cerebro, muy duradera mientras exista el objeto compuesto existe el otro.
		</li>
	</ul>
</section>

<section class="slide" id="relaciones-diferencia">
	<h2>Relaciones</h2>
	<h3>Diferencia entre asociación y composición</h3>

	<ul>
		<li>
			La diferencia con la asociación es que en la composición hacemos en algún momento la construcción de los objetos compuestos, la creación de cerebro y corazón se hace en el constructor.
		</li>
		<li>
			Los objetos que componen a la clase contenedora, deben existir desde el principio.
		</li>
		<li>
			No hay momento en que la clase contenedora pueda existir sin alguno de sus objetos componentes. Por lo que la existencia de estos objetos no debe ser abiertamente manipulada desde el exterior de la clase.

		</li>
		<li>
			Tanto la asociación como la composición se pueden entender con la frase “tiene un”
		</li>		
	</ul>
</section>

<section class="slide" id="relaciones-herencia">
	<h2>Relaciones</h2>
	<h3>Herencia</h3>

	<ul>
		<li>
			Los objetos heredan las propiedades y el comportamiento de todas las clases a las que pertenecen. 
		</li>
		<li>
			La herencia organiza y facilita el polimorfismo y el encapsulamiento, permitiendo a los objetos ser definidos y creados como tipos especializados de objetos preexistentes. Estos pueden compartir (y extender) su comportamiento sin tener que volver a implementarlo.
		</li>
		<li>
			Esto suele hacerse habitualmente agrupando los objetos en clases y estas en árboles o enrejados que reflejan un comportamiento común. Cuando un objeto hereda de más de una clase se dice que hay herencia múltiple.
		</li>
		<li>
			La herencia se puede entender como es <strong>“es un”</strong>
		</li>
	</ul>
</section>

<section class="slide" id="relaciones-herencia2">
	<h2>Relaciones</h2>
	<h3>Herencia</h3>
	<img src="herencia-figuras-geometricas.png" alt="Kitties">
	<ul>
		<li>
			la clase Cuadrado es una figura geométrica.
		</li>
		<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
			public class Cuadrado extends FiguraGeometrica{
				public double lado; 	
					
				public Cuadrado(double lado){
					super("Cuadrado");
					this.lado = lado;
				}

				public double getArea() {
					return Math.sqrt(this.lado);
				}
			}
		</script>
		<li>
			la clase Cuadrado <strong>"es una"</strong> figura geométrica.
		</li>	
	</ul>
</section>



<section class="slide" id="delegacion-polimorfismo">
	<h2>Conceptos fundamentales</h2>
	<h3>Delegación</h3>
	<ul>
		<li>
			En ocasiones, para lograr flexibilidad de diseño, un objeto es implementado de forma tal que este delegue parte de su funcionalidad en otro objeto. 
		</li>
		<li>
			Esto es muy común en aplicaciones que hacen uso de interfaces gráficas de usuario, en las que los controles gráficos generales delegan la acción que se ejecutará ante determinado estímulo en otro objeto.
		</li>	
	</ul>
	<h3>Polimorfismo</h3>
	<ul>
		<li>
			Se refiere a la habilidad de objetos de distintas clases de responder al mismo mensaje. 
		</li>
		<li>
			Esto se puede conseguir a través de la herencia: un objeto de una clase derivada es al mismo tiempo un objeto de la clase padre, de forma que allí donde se requiere un objeto de la clase padre también se puede utilizar uno de la clase hija.
		</li>	
	</ul>
</section>

<section class="slide" id="polimorfismo2">
	<h2>Conceptos fundamentales</h2>
	<h3>Polimorfismo</h3>
	<ul>
		<li>
			Upcasting: un atributo que es declarado como uno de una clase padre dentro de una jerarquía de clases va a responder a todos los métodos del padre aunque no se sepa que tipo concreto va a instanciar.
		</li>
		<li>
			Aca si bien es una asignación polimórfica se esta decidiendo en tiempo de compilación
			<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
				FiguraGeometrica figuraGeometrica1 = new Triangulo();
			</script>
		</li>
		<li>
			Se decide en tiempo de ejecución cual es la clase hija que va a ser instanciar.<BR>
			No se si figura geométrica va a ser un Triángulo o un Cuadrado hasta que no ejecute el programa.
			
			<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
			FiguraGeometrica figuraGeometrica;
			if (opcion==1){
				figuraGeometrica = new Triangulo();
			} 
			else if (opcion==1){
				figuraGeometrica = new Cuadrado();
			}
			</script>
		</li>
	</ul>
</section>

<section class="slide" id="polimorfismo3">
	<h2>Conceptos fundamentales</h2>
	<h3>Polimorfismo</h3>
	<ul>
		<li>
			downcasting: un atributo está declarado como una clase padre dentro de una jerarquía pero le específico que hijo esta instanciado.<BR>
			Nos movemos en sentido descendente en una jerarquía y en java se especifica el tipo entre paréntesis.
			<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
				dobule lado = ((Triangulo)figuraGeometrica1).lado1;
			</script>
		</li>
		<li>
			Una vez hecho el casteo se puede acceder a los métodos o atributos propios de la clase hija.
		</li>
	</ul>
</section>

<section class="slide" id="polimorfismo4">
	<h2>Conceptos fundamentales</h2>
	<h3>Polimorfismo</h3>
	<ul>
		<li>
			En ocasiones también se utiliza el término polimorfismo para referirse a la sobrecarga de métodos, término que se define como la capacidad del lenguaje de determinar qué método ejecutar de entre varios métodos con igual nombre según el tipo o número de los parámetros que se le pasa. 
		</li>

		<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
			public class Calculador {
				public static double getPerimetro(Circulo circulo){
					return 2*circulo.radio*Math.PI;
				}
				public static double getPerimetro(Cuadrado cuadrado){
					return 4*cuadrado.lado;
				}
				public static double getPerimetro(Triangulo triangulo){
					return triangulo.lado1+triangulo.lado2+triangulo.lado3;
				}
			}
		</script>
		<li>
			Los métodos se llaman exactamente igual pero se va a ejecutar el código de acuerdo a la clase del objeto que use al momento de la invocación.
		</li>
		<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
			figuraGeometrica = new Triangulo(6,6,6);	
			double perimetro =Calculador.getPerimetro((Triangulo)figuraGeometrica);
		</script>	
	</ul>
</section>

<section class="slide" id="polimorfismo5">
	<h2>Conceptos fundamentales</h2>
	<h3>Polimorfismo</h3>
	<ul>
		<li>
			Aclaración: En Python no existe sobrecarga de métodos (el último método sobre escribiría la implementación de los anteriores).
		</li>	
		<li>
			Python, al ser de tipado dinámico no impone restricciones a los tipos que se le pueden pasar a una función, por ejemplo, más allá de que el objeto se comporte como se espera: si se va a llamar a un método f del objeto pasado como parámetro, por ejemplo, evidentemente el objeto tendrá que contar con ese método. Por ese motivo, a diferencia de lenguajes de tipado estático como Java o C++, el polimorfismo en Python no es de gran importancia.
		</li>		
	</ul>
</section>

<section class="slide" id="java">
	<h2>Características del lenguaje java</h2>
	<ul>
		<li>
			Fuertemente Tipado
		</li>
		<li>
			Herencia simple
		</li>
		<li>
			Recolector de basura
		</li>
		<li>
			No es puro orientado a objetos
		</li>
		<li>
			Interpretado y compilado a la vez
		</li>
	</ul>
</section>

<section class="slide" id="java-tipado">
	<h2>Tipado estático</h2>
	<ul>
		<li>
			<strong>Tipado estático:</strong> Se dice de un lenguaje de programación que usa un tipado estático cuando el chequeo de tipificación se realiza durante el tiempo de compilación, opuesto al de ejecución.<BR> 
			Ejemplos de lenguajes que usan tipado estático son C, C++, Java.<BR>
			Comparado con el tipado dinámico, el estático permite que los errores de programación sean detectados antes, y que la ejecución del programa sea más eficiente.
			<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
				String algo = “hola”;
			</script>
		</li>
		<li>
			<strong>Tipado dinámico:</strong> Se dice de un lenguaje de programación que usa un tipado dinámico cuando el chequeo de tipificación se realiza durante el tiempo de ejecución, opuesto al de compilación. <BR>
			Ejemplos de lenguajes que usan tipado dinámico son Perl, Python y Lisp. <BR>
			Comparado con el tipado estático, o sistema de enlazado temprano, el tipado dinámico es más flexible, a pesar de ejecutarse más lentamente y más propensos a contener errores de programación.
			<script type="syntaxhighlighter" class="brush: python; toolbar: false;">
				algo = ‘hola’
				algo = 3
			</script>
		</li>	
	</ul>
</section>

<section class="slide" id="herencia-simple">
	<h2>Herencia simple</h2>
	<ul>
		<li>
			<stromg>Herencia simple:</strong> una clase sólo puede heredar comportamientos y características de una sola superclase, es decir clase puede tener un solo padre.
			</p>
			<img src="herencia-figuras-geometricas.png">
			<script type="syntaxhighlighter" class="brush: python; toolbar: false;">
				public class Cuadrado extends FiguraGeometrica{
					public double lado; 	
						
					public Cuadrado(double lado){
						super("Cuadrado");
						this.lado = lado;
					}

					public double getArea() {
						return Math.sqrt(this.lado);
					}
				}
			</script>
		</li>
	</ul>
</section>

<section class="slide" id="herencia-multiple">
	<h2>Herencia simple</h2>
	<ul>
		<li>
			<stromg>Herencia multiple:</strong> la herencia múltiple en contraste una clase puede heredar comportamientos y características de más de una superclase.
			</p>
			<img src="herencia-multiple.gif">
		</li>
	</ul>
</section>

<section class="slide" id="recolector-basura">
	<h2>Recolección de basura</h2>
	<ul>
		<li>
			El espacio de memoria se va llenando con diferentes "objetos" , también pueden destruirse algunos de ellos, dejando "huecos" en el espacio de memoria. <BR>
			Cuando ya no queda espacio disponible, o cuando lo decide la rutina de recolección de basura, la memoria es "compactada", colocando todos los "objetos" que se están usando al principio, y consolidando todos los "huecos" de memoria al final, quedando así una gran área de memoria disponible para la futura creación de objetos.
		</li>
		<li>
			<strong>ventajas y desventajas</strong>
			<ul>
				<li>
					El programador no puede cometer errores y queda liberado de la tediosa tarea de gestionar la memoria.
				</li>
				<li>
					La memoria permanece retenida durante más tiempo del estrictamente necesario.
				</li>
				<li>
					El recolector de basura tarda cierto tiempo en hacer su tarea y produce pausas que pueden hacer la técnica incompatible con sistemas de tiempo real
				</li>
			</ul>			
		</li>
	</ul>
</section>

<section class="slide" id="oonopuro">
	<h2>No es puro orientado a objetos</h2>
	<p>Hay 7 características que tiene que satisfacer un lenguaje de programación para ser orientado a objetos puro, dos de las cuales java no cumple:
	<ol>
		<li>Encapsulation/Data Hiding</li>
		<li>Inheritance</li>
		<li>Polymorphism</li>
		<li>Abstraction</li>
		<li><strong>Todos los tipos predefinidos son objetos</strong></li>
		<li><strong>Todas las operaciones se efectuan mandando mesaje a objetos</strong></li>
		<li>Todos los tipos definidos por el usuario son objetos.</li>
	</ol>
	<p>En java no todos los tipos predefinidos son objetos ni todas las operaciones se efectuan mandando mensajes a objetos</p>
</section>

<section class="slide" id="tipos_primitivos">
	<h2>No es puro orientado a objetos</h2>
	<h3>Tipos Primitivos de datos</h3>
	<ul>
		<li>boolean: 1 bytes, true o false.</li>
		<li>char: 2 bytes</li>
		<li>Enteros: Difieren en las precisiones y pueden ser positivos o negativos</li>
		<ul>
			<li>byte: 1 byte</li>
			<li>short: 2 bytes</li>
			<li>int: 4 bytes</li>
			<li>long: 8 bytes</li>
		</ul>	
		<li>Reales en punto flotante: igual que los enteros también difieren en las precisiones y pueden ser positivos o negativos.</li>

		<ul>
			<li>float: 4 bytes</li>
			<li>double: 8 bytes</li>
		</ul>
		<li>
			Un objeto es una cosa distinta a un tipo primitivo, aunque “porten” la misma información. <BR>Tener siempre presente que los objetos en Java tienen un tipo de tratamiento y los tipos primitivos, otro. <BR>
			Que en un momento dado contengan la misma información no significa en ningún caso que sean lo mismo.

			<script type="syntaxhighlighter" class="brush: python; toolbar: false;">
      			int numero = 3;
       			Integer numero2 = 4;

       			char char1 = 'a';
        		Character char2 = 'a';
			</script>
			<p>contienen la misma información pero uno es un objeto y no, uno responde a metodos y el otro no</p>
		</li>	
	</ul>
</section>
<section class="slide" id="primitivos_objetos2">
	<h2>No es puro orientado a objetos</h2>
	<h3>Tipos Primitivos de datos</h3>
	<ul>
		<li>
			Los nombres de tipos primitivos y envoltorio se parecen mucho. En realidad, excepto entre int e Integer y char y Character, la diferencia se limita a que en un caso la inicial es minúscula (por ejemplo double) y en el otro es mayúscula (Double).<BR>
			Esa similitud puede confundirnos inicialmente, pero hemos de tener muy claro qué es cada tipo y cuándo utilizar cada tipo.
		</li>
		<li>
			Una cadena de caracteres es un objeto. El tipo String en Java nos permite crear objetos que contienen texto (palabras, frases, etc.). El texto debe ir siempre entre comillas. Muchas veces se cree erróneamente que el tipo String es un tipo primitivo por analogía con otros lenguajes donde String funciona como una variable elemental. En Java no es así.
		</li>
	</ul>
</section>

<section class="slide" id="interpretado">
	<h2>Interpretado y compilado a la vez</h2>
	<ul>
		<li>
			Java es compilado, en la medida en que su código fuente se transforma en una especie de código máquina, los bytecodes, semejantes a las instrucciones de ensamblador.
		</li>
		<li>
			Por otra parte, es interpretado, ya que los bytecodes se pueden ejecutar directamente sobre cualquier máquina a la cual se hayan portado el intérprete y el sistema de ejecución en tiempo real (run-time).
		</li>	
	</ul>
</section>

<!----------------------------------------------------------------------------------------------->
<!-- deck.navigation snippet -->
<a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
<a href="#" class="deck-next-link" title="Next">&#8594;</a>

<!-- deck.status snippet -->
<p class="deck-status">
	<span class="deck-status-current"></span>
	/
	<span class="deck-status-total"></span>
</p>

<!-- deck.goto snippet -->
<form action="." method="get" class="goto-form">
	<label for="goto-slide">Go to slide:</label>
	<input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
	<datalist id="goto-datalist"></datalist>
	<input type="submit" value="Go">
</form>

<!-- deck.hash snippet -->
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>


<!-- Grab CDN jQuery, with a protocol relative URL; fall back to local if offline -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="../jquery-1.7.2.min.js"><\/script>')</script>

<!-- Deck Core and extensions -->
<script src="../core/deck.core.js"></script>
<script src="../extensions/hash/deck.hash.js"></script>
<script src="../extensions/menu/deck.menu.js"></script>
<script src="../extensions/goto/deck.goto.js"></script>
<script src="../extensions/status/deck.status.js"></script>
<script src="../extensions/navigation/deck.navigation.js"></script>
<script src="../extensions/scale/deck.scale.js"></script>

<!-- Initialize the deck -->
<script>
$(function() {
	$.deck('.slide');
});
</script>

</body>



</html>
