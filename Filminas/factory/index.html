<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js ie6" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8" lang="en"> <![endif]-->
<!--[if gt IE 8]><!-->  <html class="no-js" lang="en"> <!--<![endif]-->
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	
	<title>Factory</title>
	
	<meta name="description" content="A jQuery library for modern HTML presentations">
	<meta name="author" content="Caleb Troughton">
	<meta name="viewport" content="width=1024, user-scalable=no">
	
	<!-- Core and extension CSS files -->
	<link rel="stylesheet" href="../core/deck.core.css">
	<link rel="stylesheet" href="../extensions/goto/deck.goto.css">
	<link rel="stylesheet" href="../extensions/menu/deck.menu.css">
	<link rel="stylesheet" href="../extensions/navigation/deck.navigation.css">
	<link rel="stylesheet" href="../extensions/status/deck.status.css">
	<link rel="stylesheet" href="../extensions/hash/deck.hash.css">
	<link rel="stylesheet" href="../extensions/scale/deck.scale.css">
	
	<!-- Style theme. More available in /themes/style/ or create your own. -->
	<link rel="stylesheet" href="../themes/style/swiss.css">
	
	<!-- Transition theme. More available in /themes/transition/ or create your own. -->
	<link rel="stylesheet" href="../themes/transition/horizontal-slide.css">
	
	<script src="../modernizr.custom.js"></script>
	

    <!-- SintaxHighlighter -->
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>SyntaxHighlighter Large File Demo</title>
	<script type="text/javascript" src="../SyntaxHighlighter-master/scripts/XRegExp.js"></script>
	<script type="text/javascript" src="../SyntaxHighlighter-master/scripts/shCore.js"></script>
	<script type="text/javascript" src="../SyntaxHighlighter-master/scripts/shBrushJava.js"></script>
	<script type="text/javascript" src="../SyntaxHighlighter-master/scripts/shBrushPlain.js"></script>
	<script type="text/javascript" src="../SyntaxHighlighter-master/scripts/shBrushPython.js"></script>
	<link type="text/css" rel="stylesheet" href="../SyntaxHighlighter-master/styles/shCoreEclipse.css"/>
	<!--link type="text/css" rel="stylesheet" href="../SyntaxHighlighter-master/styles/shThemeEclipse.css"/-->
	
	<script type="text/javascript">SyntaxHighlighter.all();</script>

	
	
</head>

<body class="deck-container">

<!-- Begin slides -->
<section class="slide" id="factory0">
	<h2>Factory</h2>
	<p>Factory es un patron creacional.</p>
	<p>Los patrones creacionales abstraen el proceso de instanciación</p>
	<p>Ocultan los detalles de como se crean los objetos y ayudan a que el sistema sea independiente de la creación y composición de los mismos.</p>
	<p>Todos los lenguajes orientados a objetos tienen una manera de crear objetos. En java esto se hace con el operador new. Los patrones creacionales nos permiten crear objetos sin usar el operador new. Esto nos permite escribir métodos que pueden instanciar diferentes objetos y puede ser extendido a otros objetos que queremos sin modificar el código de los métodos.</p>
</section>
<section class="slide" id="factory1">
	<h2>Factory</h2>
	<p>A veces requiere más código instanciar los objetos que usarlos, vamos a ver como hacer que la instaciación no sea pública y evitar los problemas de acoplamiento que ocaciona la instanciación.</p>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
		Duck duck = new MallardDuck();
	</script>
	<p>Queremos usar interfaces para que quede flexible, pero en algún momento tenemos que crear una instancia de una clase concreta.</p>
	<p>Cuando tenemos un conjunto de clases concretas relacionadas, nos vemos forzados de hacer el codigo asi:</p>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
		Duck duck;
		if (picnic){
			duck = new MallardDuck();
		}
		else if (hunting){
			duck = new DecoyDuck();
		}
	</script>
</section>
<section class="slide" id="factory2">
	<h2>Factory</h2>
	<p>Acá hay varias clases concretas que están siendo instanciadas y la desicion de cual instanciar se esta haciendo en tiempo de ejecución, dependiendo de ciertas condiciones.</p>
	<p>Cuando vemos un código como este cuando viene un cambio o extenision de funcionalidad tenemos que tocar el codigo para soportar los cambios. Este tipo de código suele terminar en varias partes de la aplicación haciendo el mantenimiento y los cambios mas difíciles y propensos a fallas.</p>
	<p>Declarando los atributos a interfaces podemos aislarnos muchos cambio que vayan surgiedo. Por que?. Porque escribiendo el código a una interface el código va a andar a través del polimorfismo para cualquier clase que implemente esa interface.</p>
	<p>Sin embargo si el código tiene que usar muchas clases concretas, estamos en problemas porque ese código tiene que ser cambiado cuando queremos agregar nuevas clases concretas.</p>
	<p>En definitiva el código no esta <strong>“cerrado para modificación”</strong> ya que para extender el código con nuevas clases concretas tenemos que hacer cambios en el código.</p>
</section>
<section class="slide" id="factory3">
	<h2>Factory</h2>
	<p>Que se puede hacer? recordemos uno de los principios de OOP, decía <strong>“identifiquemos los objetos que varían y separemoslo de lo que no”.</strong></p>

	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
	static Pizza orderPizza(String type){
		Pizza pizza=null;
		//codigo que varia
		if (type.equals("Cheese")){
			pizza=new CheesePizza();
		}
		if (type.equals("Onnion")){
			pizza=new OnionPizza();
		}
		//hasta acá
		pizza.prepare();
		pizza.bake();
		pizza.cut();
		pizza.box();
		return pizza;
	}
	</script>
	<p>Si se quiere agregar alguna pizza al menú hay que modificar este código.</p>
	<p>Como se ve, lidiar con la instanciación de clases concretas molesta al método orderPizza() y evita que se pueda mantener el principio cerrado para modificación.<BR>
	Ahora que identificamos lo que varía, es momento de encapsularlo.</p>
</section>
<section class="slide" id="factory4">
	<h2>Simple Factory</h2>
	<h3>Encapsulado la creación del objeto</h3>
	<p>Entonces sabemos que tenemos que mover la creación de los objetos afuera del método</p>
	<p>Creamos otro objeto que se va a dedicar a crear las pizzas.</p>
	<h3>Factory</h3>
	<p>Los objetos Factory se ocupan de los detalles de la creación de objetos. Una vez que tenemos el SimplePizzaFactory, nuestro método orderPizza() se vuelve cliente de este objeto.</p>
	<p>Cada vez que necesitamos una pizza le pedimos a la factory de pizza que genere uno.
	Ahora el orderPizza() solo sabe que recibe una pizza que implementa la interfaz Pizza y que responde a los metodos prepare(), bake(), cut(), box()</p>
</section>
<section class="slide" id="factory5">
	<h2>Simple Factory</h2>
	<h3>Construimos una factory simple de pizza</h3>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
		public class SimplePizzaFactory {
			public Pizza createPizza(String type) {
				Pizza pizza = null;
				if (type.equals("cheese")) {
					pizza = new CheesePizza();
				} else if (type.equals("pepperoni")) {
					pizza = new PepperoniPizza();
				} else if (type.equals("clam")) {
					pizza = new ClamPizza();
				} else if (type.equals("veggie")) {
					pizza = new VeggiePizza();
				}
				return pizza;
			}
		}
	</script>
</section>
<section class="slide" id="factory6">
	<h2>Simple Factory</h2>
	<p>Cual es la ventaja de esto, parece que lo único que hicimos es pasar el problema a otro objeto?<p/>
	<p>Recordemos que SimplePizzaFactory va a tener muchos clientes, hasta hora solo vimos el método orderPizza(), sin embargo puede haber una clase PizzaMenuClass() que usa la factory obtener pizzas para la descripción y precio. También puede haber una clase HomeDelivery que maneja las pizzas en una forma distinta a la nuestro PizzaShop pero es también cliente de la factory.</p>
	<p>Encapsulando la creación de las pizzas en una clase, tenemos un solo lugar para hacer las modificaciones cuando la implementación cambie.</p>

	<p>Otra manera de implentar esto es definir la factory como un método estático. Esto es una técnica común y es llamada <strong>“static factory”</strong>.Usando un método static no necesitamos instanciar un objeto para hacer uso del método create().<BR/>
	Pero recordemos que también tiene la desventaja que no podemos hacer subclases y cambiar el comportamiento del método create().</p>
</section>
<section class="slide" id="factory7">
	<h2>Simple Factory</h2>
	<h3>Retocamos la clase PizzaStore</h3>
	<p>Vamos a arreglar el codigo cliente.<BR/>
	<p>Lo que queremos es delegar a factory, para que cree las pizzas por nosotros.</p>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
	public class PizzaStore {
		SimplePizzaFactory factory;
		public PizzaStore(SimplePizzaFactory factory) { 
			this.factory = factory;
		}
		//PizzaStore se le pasa una factory en la creación 
		//y ademas se deja una referencia para poder usarla
	 
		public Pizza orderPizza(String type) {
			Pizza pizza;
			pizza = factory.createPizza(type);
		 	//usa la factory simplemente pasando el tipo, 
		 	//ahora no hay mas instanciaciones concretas aca
			pizza.prepare();
			pizza.bake();
			pizza.cut();
			pizza.box();
			return pizza;
		}
	}
	</script>
	<p>Sabemos que las composición (tener la factory referenciada) nos permite cambiar el comportamiento dinámicamente (además de otras cosas), porque podemos cambiar de factory.</p>
	<p>usamos la simpleFactory</p>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
		public class TestSimplePizza {
			public static void main(String[] args) {
				SimplePizzaFactory factory = new SimplePizzaFactory();
				PizzaStore store = new PizzaStore(factory);
				Pizza pizza = store.orderPizza("cheese");
				pizza = store.orderPizza("veggie");
			}
		}
	</script>
</section>
<section class="slide" id="factory8">
	<h2>Simple Factory</h2>
	<p>Si bien Simple Factory no es realmente un patron de diseño vamos a definirlo ya que es algo comúnmente usado</p>
	<p>Clase con responsabilidad de crear objetos de otras clases. No delega en subclases y sus métodos pueden ser estáticos.</p>
	<p>Diagrama de la pizzeria incorporando <strong>simple factory</strong></p>
	<img src="simplePizzaFactory.png"/>
</section>
<section class="slide" id="factory9">
	<h2>Simple Factory</h2>
	<ul>
		<li><strong>PizzaStore:</strong> es el cliente de la factory. PizzaFactory ahora usa a SimplePizzaFacrory para obtener instacias de Pizza.</li>
		<li><strong>SimplePizzaFactory:</strong> es la fabrica de Pizzas, este debería ser el único lugar donde la aplicacion hace referecia a las clases concretas. El método create suele ser declarado estatico.</li>
		<li><strong>Pizza:</strong> es el producto de la factory de Pizza.<BR/>
		Definimos Pizza como una clase abstracta con algunas implementación útiles que pueden ser sobreescritas.</li>
		<li><strong>Los productos concretos:</strong> (ChesePizza, VeggiePizza) cada uno tiene que implementar la interfaz Pizza, que en este contexto significa extender de la clase abstracta pizza y ser concreta. Mientras este sea el caso puede ser creada por la factory y pasada al cliente.</li>
	</ul>
	<p></p>
</section>
<section class="slide" id="factory10">
	<h2>Factory method</h2>
	<h3>Haciendo un fanquicia de la tienda de Pizza</h3>
	<p>Tenemos varias franquicias, Chicago, New York y California</p>
	<p>El objetivo es que todas las franquicias usen el código de PizzaStore así las pizzas son preparadas de la misma manera.</p>
	<p>Hay una manera de poner todas las actividades de creación de pizza en la tienda y darle a los franquiciantes la libertad de tener su propio estilo de pizza regional.
	Lo que vamos a hacer es poner el método createPizza() de nuevo en pizzaStore pero esta vez lo vamos declarar como abstracto (sin implementación), y una subclase para cada estilo regional.</p>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
	public abstract class PizzaStore {
		public Pizza orderPizza(String type) {
			Pizza pizza = createPizza(type);
			//ahora createPizza() esta siendo un metodo que se llama 
			//desde la clase PizzaStore en vez de un objeto factory

			System.out.println("--- Making a " + pizza.getName() + " ---");
			pizza.prepare();
			pizza.bake();
			pizza.cut();
			pizza.box();
			return pizza;
		}
		public abstract Pizza createPizza(String item);
	}
	</script>

</section>
<section class="slide" id="factory11">
	<h2>Factory method</h2>
	<p>Ahora hacemos una subclase para cada regional</p>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
	public class ChicagoPizzaStore extends PizzaStore {

		Pizza createPizza(String item) {
	        	if (item.equals("cheese")) {
	            		return new ChicagoStyleCheesePizza();
	        	} else if (item.equals("veggie")) {
	        	    	return new ChicagoStyleVeggiePizza();
	        	} else if (item.equals("clam")) {
	        	    	return new ChicagoStyleClamPizza();
	        	} else if (item.equals("pepperoni")) {
	            		return new ChicagoStylePepperoniPizza();
	        	} else return null;
		}
	}
	</script>
</section>
<section class="slide" id="factory12">
	<h2>Factory method</h2>
	<p><strong>Permitiendo a la subclase decidir</strong></p>
	<p>Recordemos que PizzaStore, ya tiene todo solucionado en el método orderPizza() y queremos asegurarnos que sea consistente con todas las franquicias.<BR/>
	Lo que varía entre las distintas regionales es es estilo de pizza, mas gruesa, mas fina, con más salsa o con más queso.</p>
	<p>Vamos a meter todas estas variaciones en el métodos createPizza() (que cada subclase  tiene que implementar) y hacerlo responsable de crear el tipo correcto de pizza.</p>
	<p>La forma que hacemos esto es dejando a cada subclase de PizzaStore definir el método createPizza(). Entonces vamos a tener un numero de subclases clases concretas de PizzaStore, cada una con sus variaciones de Pizza, y así completando el framework y se sigue usando el método orderPizza() para todos.</p>

</section>
<section class="slide" id="factory13">
	<h2>Factory method</h2>
	<img src="fatoryMethodPizzaStore.png"/>
	<p>Cada subclase sobreescribe el método createPizza() mientras todas las clases hacen uso de orderPizza() definido en la clase PizzaStore.</p>
	<p>Podemos hacer el método orderPizza() final si realmente queremos esto. Con esto nadie lo puede sobreescribir</p>
	<p>Recordemos createPizza() es abstracto en PizzaStore, con lo cual todas las subclases de pizza deben implementarlo</p>
</section>

<section class="slide" id="factory14">
	<h2>Factory method</h2>
	<ul>
		<li>Se está realmente tomando una desicion ?<BR/>
			Desde el punto de vista del método <strong>orderPizza()</strong> de PizzaStore, como esta definido en la clase abstracta PizzaStore, no tiene idea que subclase esta corriendo el código y haciendo las pizzas.<BR/>
			En otras palabras esta desacoplado.
		</li>
		<li><strong>orderPizza()</strong> llama a <strong>createPizza()</strong> para obtener un objeto Pizza, pero que tipo 	de Pizza va a obtener?<BR/> 
			El método <strong>orderPizza()</strong> no puede decidir, no sabe como, entonces quien decide?
			Esto esta decidido de acuerdo a el pizza store desde que se hizo la llamada NYPizzaStore o ChicagoPizzaStore.
		</li>
		<li>Entonces hay una decicion en tiempo de ejecucion?</BR>
			NO, pero desde las perspectiva de orderPizza() si elegimos NYStyePizzaStore, esa clase determina que tipo de pizza se va a hacer. Entonces las subclases no están decidiendo, sino uno mismo cuando decide que tipo de tienda se quiere (tiempo de compilación) y de acuerdo a esto es la clase que se instancia la que sabe qué tipo de pizza se va a hacer.
		</li>
	</ul>	
</section>
<section class="slide" id="factory15">
	<h2>Factory method</h2>
	<h3>Pasos para crear una pizza</h3>
	<ul>
		<li>primero necesitamos un PizzaStore, por ejemplo NYPizzaStore
		<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
		PizzaStore nyPizzaStore = new NYPIzzaStore();
		</script>
		Creamos una instancia de PizzaStore
		</li>
		<li>
			Ahora que tenemos la tienda podemos hacer la orden
			<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
			nyPizzaStore.orderPizza(“chesse”);
			</script>
			el método orderPizza es llamado en las instacia de PizzaStore (el metodo definido en PizzaStore se ejecuta)
		</li>
		<li>
			el método orderPizza() llama al método createPizza()
			<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
			Pizza pizza = createPizza(“chesse”);
			</script>
			recordemos que createPizza(), el metodo factory esta implementado en la subclase. En este caso retorno a NYChessePizza
		</li>
	</ul>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
		public class TestPizza { 
			public static void main(String[] args) {
				PizzaStore nyStore = new NYPizzaStore();
				Pizza pizza = nyStore.orderPizza("cheese");
				System.out.println("Ethan ordered a " + pizza.getName() + "\n");
			}
		}
	</script>
</section>
<section class="slide" id="factory16">
	<h2>Factory method</h2>
	<h3>Pasos para crear una pizza</h3>
	<ul>
		<li>
			Finalmente tenemos la pizza sin preparar y el metodo orderPizza() la termina de preparar la pizza.
			<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
				pizza.prepare();
				pizza.bake();
				pizza.cut();
				pizza.box();
				</script>
			recordemos que createPizza(), el metodo factory esta implementado en la subclase. En este caso retorno a NYChessePizza
		</li>
	</ul>
	<p>todos estos métodos están definidos en la pizza especifica devuelta por el método fabrica createPizza() definido en NYPizzaStore.</p>
	<p>El método  orderPizza() obtiene una pizza, sin saber exactamente que clase concreta es.</p>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
	public abstract class Pizza {
		String name;
		String dough;
		String sauce;
		ArrayList toppings = new ArrayList();
	 
		void prepare() {
			System.out.println("Preparing " + name);
			System.out.println("Tossing dough...");
			System.out.println("Adding sauce...");
			System.out.println("Adding toppings: ");
			for (int i = 0; i < toppings.size(); i++) {
				System.out.println("   " + toppings.get(i));
			}
		}
		void bake() {
			System.out.println("Bake for 25 minutes at 350");
		}
		void cut() {
			System.out.println("Cutting the pizza into diagonal slices");
		}
		void box() {
			System.out.println("Place pizza in official PizzaStore box");
		}
	}
	</script>
</section>
<section class="slide" id="factory17">
	<h2>Factory method</h2>
	<h3>Definicion del Metodo Factory</h3>
	<p>Define herencia para la creación de un objeto, pero deja a las subclases decidir qué clase instanciar. El método factory deja a una clase definir las instanciación de las subclases.<BR/>
	Como cualquier factory, el patrón factory method nos da una manera de encapsular la creación de tipos concretos.<BR/>
	También conocido como Virtual Constructor</p>
	<ul>
		<li>Clasificación: Es un patrón de diseño de cracional de clase ya que usa la herencia como un mecanismo para lograr la instanciación de la Clase.</li>
		<li>Motivación: Una clase necesita instanciar otra clase derivada de una tercera clase, pero no sabe cuál. Factory Method permite a la clase derivada tomar esta decisión.</li>
		<li>Aplicabilidad:</li>
		<ul>
			<li>Una clase no puede prever la clase de objetos que debe crear.</li>
			<li>Una clase quiere que sean sus subclases quienes especifiquen los objetos que ésta crea.</li>
			<li>Las clases delegan la responsabilidad en una de entre varias clases auxiliares, y queremos localizar concretamente en qué subclase de auxiliar se delega.</li>
		</ul>
		<li>Consecuencias:</li>
		<ul>
			<li>Crear objetos dentro de una clase con un método de fabricación es siempre más flexible que hacerlo directamente.</li>
			<li>Encapsula la creación de objetos</li>
			<li>Conecta jerarquías de clases paralelas.</li>
			<li>Promueve el bajo acoplamiento reduciendo la dependencia de la aplicación a clases concretas</li>
			<li>Una poderosa técnica para programar a una abstracción no a una clase concreta</li>
		</ul>
	</ul>	
</section>
<section class="slide" id="factory18">
	<h2>Factory method</h2>
	<h3>Definicion del Metodo Factory</h3>
	<p>Participantes:</p>
	<ul>
		<li><strong>Product:</strong> Define la interfaz de los objetos que crea el método de fabricación.</li>
		<li><strong>Concrete Product:</strong> Implementa la interfaz Producto.</li>
		<li><strong>Creator: </strong>
		<ul>
			<li>Declara el método de fabricación, el cual devuelve un objeto del tipo Producto.</li> 
			<li>También puede definir una implementación predeterminada del método de fabricación que devuelve un objeto.</li>
			<li>Puede llamar al método de fabricación para crear un objeto Producto. Esto es usa el método que tiene definido como abstracto</li>
			<li>Frecuentemente el creator contiene código que depende en productos abstractos, que es producido por una subclase.<BR/>
			El creator nunca sabe en realidad que producto concreto fue producido.</li>
		</ul>	
		<li><strong>Concrete Creators:</strong> Redefine el método de fabricación para devolver una instancia de Producto Concreto.</li>
	</ul>	
</section>
<section class="slide" id="factory18b">
	<h2>Factory method</h2>
	<img src="factoryMethodClassDiagram.png">
</section>
<section class="slide" id="factory19">
	<h2>Factory method</h2>
	<h3>Participantes en el Pizza Store</h3>
	<p><strong>Creator:</strong> PizzaStore es la clase abtract creator. Define el método factory abstracto que las subclases implementan para producir productos.</p>
	<img src="fatoryMethodPizzaStore.png"/>	
	<p>"Frecuentemente el creator contiene código que depende en productos abstractos, que es producido por una subclase".<BR/>
	Esto se refiere a la parte del el método orderPizza() que usa pizza sin saber que pizza es, lo que si sabe es que es una pizza y por lo tanto entiende repare(), bake(), cut() y box()</p>
	<p>	"Puede llamar al método de fabricación para crear un objeto Producto.<BR/>
	Esto es usa el método que tiene definido como abstracto createPizza()"</p>

	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
	public abstract class PizzaStore {
		public Pizza orderPizza(String type) {
			Pizza pizza = createPizza(type);

			System.out.println("--- Making a " + pizza.getName() + " ---");
			pizza.prepare();
			pizza.bake();
			pizza.cut();
			pizza.box();
			return pizza;
		}
		public abstract Pizza createPizza(String item);
	}
	</script>
	</p>
</section>
<section class="slide" id="factory20">
	<h2>Factory method</h2>
	<h3>Participantes en el Pizza Store</h3>
	<p><strong>Concrete creators:</strong>  NyPizzaStore y ChicagoPizzaStore son las clases llamadas concrete creators.<BR/>
	El método createPizza() es nuestro método factory, el que produce los productos concretos.<BR/>
	Dado que cada franquicia tiene su propia subclase es libre de crear su propio estilo de pizza implementando createPizza()</p>
	<p><strong>Product:</strong> Pizza es la clase prodcut</p>
	<p><strong>Concrete Product:</strong> son los distintos tipos de pizzas producidos por las tiendas de NewYork y de Chicago</p>
	<img src="fatoryMethodProducts.png"/>
</section>
<section class="slide" id="factory21">
	<h2>Factory method</h2>
	<h3>Otra Perspectiva: geraquias de clases paralelas</h3>
	<p> Otra manera de mirar este patrón además de como un framework, es en la manera que encapsula el conocimiento de los productos en cada creador.<br/>
	Miremos las dos jerarquías de clases y miremos cómo se relacionan.</p>
	<img src="parallelHierarchies.png"/>
	<p>Ambas jerarquías de clases son paralelas: ambas tienen clases abstractas que son extendidas por clases concretas, que saben sobre las implementaciones específicas de de New York y Chicago.</p>
	<p>NYPizzaStore encapsula el conocimiento sobre como hacer NYStylePizzas<BR/>
	ChicagoPizzaStore encapsula el conocimiento sobre como hacer ChicagoStylePizzas
	<p>El factory method es la clave para encapsular este conocimiento.</p>
</section>
<section class="slide" id="factory22">
	<h2>Principio de diseño</h2>
	<h3>Principio de la inversión de dependencias</h3>
	<p>dependa de abstracciones, no dependa de clases concretas.</p>
	<ul>
		<li>Debería ser claro que la reducción de las dependencias para crear clases en nuestro código es una cosa buena.</li>
		<li>Al principio suena como <strong>“programa a una interface no a una implementación”</strong>.<BR/>
		Es similar sin embargo el principio de inversión de dependencia hace una declaración más fuerte en cuanto abstracción.<BR/>
		Sugiere que los componentes de alto nivel, no deben depender en los de bajo nivel, ya que ambos deben depender de abstracciones.
	</li>
	<li>Un componente de alto nivel es una clase con comportamiento definido en términos de otra “la de bajo nivel”.<BR/>
		Por ejemplo PizzaStore es un componente de alto nivel porque su comportamiento está definido en de pizzas, crea todos los objetos pizzas, los prepara, los cocina, etc mientras las pizzas que usan son de bajo nivel.
	</li>
	</ul>	
</section>
<section class="slide" id="factory23">
	<h2>Principio de diseño</h2>
	<h3>Principio de la inversión de dependencias</h3>
	<img src="inversionPrinciple.png"/>
	<p>PizzaStore ahora solo depende de la clase abstracta Pizza</p>
	<p>Las clases Pizza concretas dependen de abstract Pizza porque implementan la interfaz Pizza (recordemos que estamos usando el término interface en el sentido general).</p>
	<p>nuestro componente de alto nivel PizzaStore, y los componentes de bajo nivel las pizzas ambos dependen de Pizza, la abstraccion.</p>
	<p>Factory method no es la única manera de aplicar el principio de inversion de dependencias, pero es uno de los poderosos.</p>
</section>
<section class="slide" id="factory24">
	<h2>Principio de diseño</h2>
	<h3>Guías para seguir el principio de inversión de dependencias</h3>
	<ul>
		<li>Ninguna variable debe referenciar a una clase concreta<BR/>
			Si se usa <strong>new</strong> estamos referenciando a una clase concreta. Usar factory para hacer esto.
		</li>
		<li>Ninguna clase debe derivar de una clase concreta<BR/>
			Si uno deriva de una clase concreta, estas dependiendo de una clase concreta.<BR/>
			Derivar de una abstracción, como una interfaz o una clase abstracta.
		</li>
		<li>Ningún método debería sobre escribir un método implementado de ninguna de sus clases bases.<BR/>
			Si uno sobre escribe un método implementado entonces la clase base no fue realmente una abstracción 
		</li>	
	</ul>
	<p>Tengamos en cuenta que es una guía y que siempre voy a estar rompiendo estas reglas, pero la idea es saber que lo estamos haciendo y por qué</p>
</section>
<section class="slide" id="factory25">
	<h2>Abstract Factory</h2>
	<h3>Familia de ingredientes</h3>
	<p>Todas las pizzas estan hechas a base de los mismos componentes pero con distintas implementaciones de esos componentes. Lo que es salsa roja en New York no es salsa roja en chicago (tienen diferentes ingredientes), cada una de las sucursales tienen una familia de ingredientes.</p>
	<p>Tenemos que ver como vamos a manejar las familias de ingredientes.</p>
	<p><strong>Haciendo la ingredient factory</strong></p>
	<p>La factory va a ser responsable de la creación de cada ingrediente en la familia de ingredientes.</BR>
	En otras palabras la fábrica va a necesitar crear dough, sauce, cheese, etc.</p>
	<p>Definimos la interfaz de la factory que va a crear los ingredientes.</p>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
	public interface PizzaIngredientFactory {
		public Dough createDough();
		public Sauce createSauce();
		public Cheese createCheese();
		public Veggies[] createVeggies();
		public Pepperoni createPepperoni();
		public Clams createClam();
	}
	</script>
	<p>Para cada ingrediente definimos un create method en nuestra interface.</p>
</section>
<section class="slide" id="factory26">
	<h2>Abstract Factory</h2>
	<h3>Ingredient Factory</h3>
	<p><strong>Esto es lo que vamos a hacer</strong></p>
	<ul>
		<li>Construir una fábrica para cada región. Para hacer esto vamos a crear una subclase de PizzaIngredientFactory que implementa cada create method.</li>
		<li>Implementar un conjunto de clases de ingredientes para ser usados con la factory, como ReggianoChesse, RedPeppers and ThickCrustDought. Estas clases pueden ser compartidas entre regiones.</li>
		<li>Despues tenemos que hacer andar nuestra fabrica de ingredientes en el codigo de el codigo viejo de PizzaStore.</li>
	</ul>
</section>
<section class="slide" id="factory27">
	<h2>Abstract Factory</h2>
	<h3>Ingredient Factory</h3>
	<p><strong>Construyendo la fábrica de ingredientes de New York.</strong></p>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
	public class NYPizzaIngredientFactory implements PizzaIngredientFactory {
		public Dough createDough() {
			return new ThinCrustDough();
		}
		public Sauce createSauce() {
			return new MarinaraSauce();
		}
		public Cheese createCheese() {
			return new ReggianoCheese();
		}
		public Veggies[] createVeggies() {
			Veggies veggies[] = { new Garlic(), new Onion(), new Mushroom(), new RedPepper() };
			return veggies;
		}
		public Pepperoni createPepperoni() {
			return new SlicedPepperoni();
		}
		public Clams createClam() {
			return new FreshClams();
		}
	}
	</script>
	<p>La factory de New York implementa la interface para todas las factories de ingredientes.<BR/> 
		Para los vegetales retornamos un array de vegetales
	</p>
</section>
<section class="slide" id="factory28">
	<h2>Abstract Factory</h2>
	<h3>Ingredient Factory</h3>
	<img src="IngredientFactory.png"/>
</section>
<section class="slide" id="factory28b">
	<h2>Abstract Factory</h2>
	<h3>Ingredient Factory</h3>
	<p><strong>Ahora los ingredientes</strong></p>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
	public interface Cheese {
		public String toString();
	}
	</script>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
	public class ReggianoCheese implements Cheese {
		public String toString() {
			return "Reggiano Cheese";
		}
	}
	</script>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
	public class MozzarellaCheese implements Cheese {
			public String toString() {
				return "Shredded Mozzarella";
			}
		}
	}	
	</script>
</section>
<section class="slide" id="factory29">
	<h2>Abstract Factory</h2>
	<h3>Ingredient Factory</h3>
	<p>Ya está la fábrica lista para producir los ingredientes , tenemos que arreglar Pizza para usarla.</p>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
	public abstract class Pizza {
		String name;
		Dough dough;
		Sauce sauce;
		Veggies veggies[];
		Cheese cheese;
		Pepperoni pepperoni;
		Clams clam;
		abstract void prepare();

		void bake() {
			System.out.println("Bake for 25 minutes at 350");
		}
		void cut() {
			System.out.println("Cutting the pizza into diagonal slices");
		}
		void box() {
			System.out.println("Place pizza in official PizzaStore box");
		}
		void setName(String name) {
			this.name = name;
		}
		String getName() {
			return name;
		}
		public String toString() {
			//code to print pizza
		}
	}
	</script>
</section>
<section class="slide" id="factory30">
	<h2>Abstract Factory</h2>
	<h3>Ingredient Factory</h3>
	<img src="PizzaIngredientFactory.png"/>
	<p>Ahora que tenemos un abstract Pizza es hora de crear los estilos de Pizza de New York y Chicago, solo que esta vez van a obtener los ingredientes directamente de la fábrica.</p>
</section>
<section class="slide" id="factory31">
	<h2>Abstract Factory</h2>
	<h3>Ingredient Factory</h3>
	<p>Cuando escribimos el código de factory method teníamos las clases NYChessePizza y ChicagoChessePizza.</p>
	<p>Si miramos las dos clases lo único en lo que difieren es en los ingredientes, las pizzas están hechas igual dough (masa), sauce, cheese, y lo mismo pasa con las otras pizzas Veggie, Clam, todas tienen los mismos pasos de preparación y lo que cambia son los ingredientes.</p>
	<p>Ya no vamos a necesitar 2 clases para cada estilo de pizza (pizza de queso tienen NYChessePizza y ChicagoChessePizza)</p>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
	public class CheesePizza extends Pizza {
		PizzaIngredientFactory ingredientFactory;
	 
		public CheesePizza(PizzaIngredientFactory ingredientFactory) {
			this.ingredientFactory = ingredientFactory;
		}
	 
		void prepare() {
			System.out.println("Preparing " + name);
			dough = ingredientFactory.createDough();
			sauce = ingredientFactory.createSauce();
			cheese = ingredientFactory.createCheese();
		}
	}
	</script>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
	public class PepperoniPizza extends Pizza {
		PizzaIngredientFactory ingredientFactory;
		public PepperoniPizza(PizzaIngredientFactory ingredientFactory) {
			this.ingredientFactory = ingredientFactory;
		}
		void prepare() {
			System.out.println("Preparing " + name);
			dough = ingredientFactory.createDough();
			sauce = ingredientFactory.createSauce();
			cheese = ingredientFactory.createCheese();
			veggies = ingredientFactory.createVeggies();
			pepperoni = ingredientFactory.createPepperoni();
		}
	}
	</script>
	<p>Para hacer una Pizza ahora necesitamos un ingredientFactory, entonces a cada clase Pizza se le pasa una factory en el constructor y guarda una instancia de la factory en una variable.</p>
</section>
<section class="slide" id="factory32">
	<h2>Abstract Factory</h2>
	<img src="PizzaIngredientFactory-Pizza.png"/>
	<p><strong>Código cerrado</strong></p>
	<p>El codigo Pizza usa la factory que fue compuesta (relación de composición) para producir los ingredientes usados en la pizza. <BR/>
Los ingredientes producidos dependen de qué factory estamos usando. A la clase Pizza no le importa, sabe como hacer Pizzas. </p>
</section>
<section class="slide" id="factory33">
	<h2>Abstract Factory</h2>
	<p>Ahora está desacoplado de las diferencias en los ingredientes regionales y puede ser fácilmente re usado por otras regionales.</p>
	<p>Si queremos agregar otros ingredientes regionales hacemos otra factory de ingredientes, o podemos usar una de las existentes.</p>
	<p>ingredientFactory es nuestra factory a la clase Pizza no le interesa que factory se usa mientras se una ingredientFactory.</p>
	<h3>Veamos como quedan NYPizzaStore y ChicagoPizzaStore</h3>
	<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
	public class NYPizzaStore extends PizzaStore {
		protected Pizza createPizza(String item) {
			Pizza pizza = null;
			PizzaIngredientFactory ingredientFactory = 
				new NYPizzaIngredientFactory();
			if (item.equals("cheese")) {
				pizza = new CheesePizza(ingredientFactory);
				pizza.setName("New York Style Cheese Pizza");
			} else if (item.equals("veggie")) {
	 
				pizza = new VeggiePizza(ingredientFactory);
				pizza.setName("New York Style Veggie Pizza");
			} else if (item.equals("clam")) {
				pizza = new ClamPizza(ingredientFactory);
				pizza.setName("New York Style Clam Pizza");
			} else if (item.equals("pepperoni")) {
				pizza = new PepperoniPizza(ingredientFactory);
				pizza.setName("New York Style Pepperoni Pizza");
			}
			return pizza;
		}
	}
	</script>
</section>
<section class="slide" id="factory34">
	<h2>Abstract Factory</h2>
	<p><strong>Qué fue lo que hicimos</strong></p>
	<p>Creamos una manera de crear ingredientes para pizzas introduciendo un nuevo tipo de fábrica llamada abstract factory</p>
	<p>Una abstract Factory nos da una interface para crear una familia de productos.</p>
	<p>Escribiendo código que use esta interface, desacoplamos el código de la fábrica actual que crea productos.</p>
	<p>Eso nos permite implementar una variedad de factories que producen productos pensados para distintos contextos (diferentes regiones, sistemas operativos o aspectos visuales)<BR/>
	Como nuestro código está desacoplado de los productos actuales, podemos sustituir distintas factories y obtener diferentes comportamientos (como obtener salsa mariana en vez de salsa de tomate)</p>
	<p>En nuestro casa la familia de productos, son las cosas que necesitamos para hacer pizzas: dough, sauce, cheese, meats y verggies.<BR/>
	Pasando distintas factories al cliente (PizzaStore) obtenemos una variedad de implementaciones de esos productos, pero el código cliente sigue igual.</p>
</section>
<section class="slide" id="factory35">
	<h2>Abstract Factory</h2>
	<p><strong>Como ordenamos una pizza ahora?</strong></p>
	<ol>
		<li>Necesitamos un PizzaStore
			<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
				PizzaStore nyPizzaStore = new NYPizzaStore();
			</script>
		</li>
		<li>Ahora que tenemos una tienda, podemos tomar las ordenes
			<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
				nyPizzaStore.orderPizza(“chesse”);
			</script>
		</li>
		<li>El metodo orderPizza() primero llama al metodo createPizza()
			<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
				Pizza pizza = createPizza(“cheese”);
			</script>
		</li>
		<li>Cuando el metodo cretePizza() es llamado, ahi es cuando la fábrica de ingredientes es invocada.
			<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
				Pizza pizza = new CheesePizza(nyIngredientFactory);
			</script>
			La fábrica de ingredientes es elegida e instanciada en NYPizzaStore y luedo es pasada en el constructor de cada pizza.<BR/>
			Crea una nueva instacia de ChessePizza que esta compueta con NYIngredientFactory
		</li>
	</ol>
</section>
<section class="slide" id="factory36">
	<h2>Abstract Factory</h2>
	<p><strong>Como ordenamos una pizza ahora?</strong></p>
	<ol start="5">
		<li>Lo proximo que necesitamos es preparar la pizza. Una vez que el metodo prepare() es llamado, la factory prepara los ingredientes.
			<script type="syntaxhighlighter" class="brush: java; toolbar: false;">
				void prepare(){
					dough = factory.createDogh();   //masa fina
					sauce = factory.createSauce();  //Mariana
					cheese = factory.createCheese(); //Raggiano
				} 
			</script>
		</li>
		<li>Finalmente tenemos la Pizza en la mano y el método orderPizza() bakes, cuts y boxes.</li>
	</ol>
</section>
<section class="slide" id="factory37">
	<h2>Patrón Abstract Factory</h2>
	<p>Abstrac factory pattern provee una interface para crear una familia de objetos relacionados o dependientes sin especificar sus clases concretas.</p>
	<ul>
		<li>Clasificación: Es un patrón creacional de objetos.</li>
		<li>Motivación: Se necesita instanciar familias de objetos.</li>	
		<li>Aplicabilidad: 
			<ul>
				<li>Un sistema debe ser independiente de cómo se crean, componen y representan sus productos.</li>
				<li>Un sistema debe ser configurado con una familia de productos entre varias.</li>
				<li>Una familia de objetos producto relacionados está diseñada para ser usada conjuntamente y es necesario hacer cumplir esa restricción.</li>
				<li>Se quiere proporcionar una biblioteca de clases de productos y sólo se quiere revelar sus interfaces, no sus implementaciones.</li>
			</ul>
		</li>
		<li>Consecuencias: 
			<ul>
				<li>Aísla las clases concretas.</li>
				<li>Facilita el intercambio de familias de productos.</li>
				<li>Promueve la consistencia entre productos.</li>
				<li>Una desventaja que tiene es que es difícil dar cabida a nuevos tipos de productos.</li>
			</ul>	
		</li>
	</ul>	
</section>
<section class="slide" id="factory38">
	<h2>Patrón Abstract Factory</h2>
	<ul>
		<li>Participantes: 
			<ul>
				<li><strong>Abstract Factory:</strong> Declara una interfaz para operaciones que crean objetos producto abstractos.</li>
				<li><strong>Concrete Factory:</strong> Implementa las operaciones para crear objetos producto concretos.</li>
				<li><strong>Abstract Product:</strong> Declara una interfaz para un tipo de objeto producto.</li>
				<li><strong>Concrete Product:</strong> Define un objeto producto para que sea creado por la fábrica correspondiente. Implementa la interfase ProductoAbstracto.</li>
				<li><strong>Client:</strong> Sólo usa interfaces declaradas por las clases FabricaAbstracta y ProductoAbstracto.</li>
			</ul>
			<li><strong>Estructura: </strong>
				<img src="abstractFactoryClassDiagram.png"/>
			</li>
	</ul>
</section>
<section class="slide" id="factory39">
	<h2>Resumen Factories</h2>
	<ul>
		<li><strong>Simple Factory: </strong>
		Clase con responsabilidad de crear objetos de otras clases. No delega en subclases y sus métodos pueden ser estáticos. Puede evolucionar a un abstact factory o a un factory method.</li>
		<li><strong>Factory Method:</strong> Define una interfaz para crear objetos pero deja que sean las subclases las que deciden qué clases instanciar.<BR/> Permite que una clase delegue a sus subclases la creación de objetos.<BR/>
		Usa herencia para crear productos</li>	
		<li><strong>Abstract Factory:</strong> Proporciona una interfaz para crear familias de objetos relacionados o que dependen entre sí, sin especificar sus clases concretas.<BR/>
		Usa composición para crear objetos<BR/>
		Usa factory methods</li>
	</ul>
</section>

<section class="slide" id="factory88">
	<h2>Referencias</h2>
	<p><strong>Head First Design Patterns</strong></p>
</section>

<!----------------------------------------------------------------------------------------------->
<!-- deck.navigation snippet -->
<a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
<a href="#" class="deck-next-link" title="Next">&#8594;</a>

<!-- deck.status snippet -->
<p class="deck-status">
	<span class="deck-status-current"></span>
	/
	<span class="deck-status-total"></span>
</p>

<!-- deck.goto snippet -->
<form action="." method="get" class="goto-form">
	<label for="goto-slide">Go to slide:</label>
	<input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
	<datalist id="goto-datalist"></datalist>
	<input type="submit" value="Go">
</form>

<!-- deck.hash snippet -->
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>


<!-- Grab CDN jQuery, with a protocol relative URL; fall back to local if offline -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="../jquery-1.7.2.min.js"><\/script>')</script>

<!-- Deck Core and extensions -->
<script src="../core/deck.core.js"></script>
<script src="../extensions/hash/deck.hash.js"></script>
<script src="../extensions/menu/deck.menu.js"></script>
<script src="../extensions/goto/deck.goto.js"></script>
<script src="../extensions/status/deck.status.js"></script>
<script src="../extensions/navigation/deck.navigation.js"></script>
<script src="../extensions/scale/deck.scale.js"></script>

<!-- Initialize the deck -->
<script>
$(function() {
	$.deck('.slide');
});
</script>

</body>



</html>
